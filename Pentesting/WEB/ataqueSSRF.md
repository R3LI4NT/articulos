<p align="center">
  <a href="https://github.com/DenverCoder1/readme-typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=1000&color=D1F700&width=400&lines=Explotar+vulnerabilidad+SSRF"></a>
</p>

<h1 align="center"></h1>

<h3 align="center"><ins>VULNERABILIDAD SSRF | Server-side Request Forgery  |</ins></h3>

La vulnerabilidad SSRF (Server-Side Request Forgery) ocurre en aplicaciones web cuando un atacante puede manipular el servidor para realizar solicitudes a otros servidores internos o externos, a menudo con privilegios que el atacante no tiene. Este tipo de ataque puede llevar a la exposición de información interna, escaneo de puertos internos, y en algunos casos, ejecución de comandos en el servidor.

### Requisitos previos para un Ataque SSRF
Para explotar una vulnerabilidad SSRF (Server-Side Request Forgery), deben cumplirse varias condiciones esenciales:

- `Encontrar un punto de entrada`: El atacante debe identificar una funcionalidad en la aplicación que permita enviar solicitudes a ubicaciones específicas. Ejemplos incluyen formularios de carga de URL, servicios de obtención de recursos remotos, o API que procesan URLs suministradas por el usuario.

- `Entender el contexto de la solicitud`: El atacante debe comprender cómo se manejan y procesan las solicitudes en el servidor, incluyendo cabeceras, métodos HTTP, y cualquier mecanismo de autenticación.

- `Acceso a recursos iternos`: En muchos casos, los ataques SSRF son efectivos porque el servidor tiene acceso a recursos internos que no son directamente accesibles desde el exterior. Estos pueden incluir servicios internos, bases de datos, o incluso sistemas de administración interna.

### Ejemplos de Acciones Maliciosas mediante SSRF

- `Exfiltración de datos`: Obtener datos sensibles almacenados en servidores internos, como configuraciones de bases de datos, credenciales, o información privada de usuarios.

- `Escaneo de puertos`: Utilizar la capacidad del servidor para escanear la red interna y descubrir servicios que están en ejecución, potencialmente exponiendo vulnerabilidades adicionales.

- `Desencadenar acciones en otros servicios`: Enviar solicitudes que desencadenen acciones en otros servicios internos, como iniciar procesos, modificar datos, o incluso ejecutar comandos.

- `Acceso a metadatos de nube`: En entornos de nube, los ataques SSRF pueden ser utilizados para acceder a metadatos de instancia, permitiendo la obtención de credenciales y otra información crítica.

**En resumen:**

> Para que un ataque SSRF sea posible, el atacante debe identificar un punto de entrada que permita el envío de solicitudes, comprender el contexto de cómo se manejan estas solicitudes en el servidor, y apuntar a recursos internos o sensibles que pueden ser explotados a través de la capacidad del servidor para comunicarse con otros sistemas.

<p align="center">
  <img src="https://github.com/R3LI4NT/articulos/blob/main/Pentesting/WEB/img/ataqueSSRF.png">
</p>

### Resumen del Proceso:

- 1)- El atacante envía una solicitud maliciosa al servidor público.
  
- 2)- El servidor público procesa la solicitud y extrae la URL interna.
  
- 3)- El servidor público envía una solicitud a la URL interna en la red interna.
  
- 4)- El servidor en la red interna responde con el contenido solicitado.
  
- 5)- El servidor público reenvía la respuesta al atacante, quien recibe la información sensible del servidor interno.

Este esquema muestra cómo una vulnerabilidad SSRF permite a un atacante acceder a recursos internos a través de un servidor público que actúa como intermediario.


<h1 align="center"></h1>

### EXPLOTAR SSRF | Burp Suite

En el siguiente ejemplo, utilizaré los laboratorios de PortSwigger para explotar la vulnerabilidad SSRF mediante la herramienta Burp Suite. Estos laboratorios son gratuitos y solo requieren la creación de una cuenta: https://portswigger.net/web-security/ssrf.

![1](https://github.com/user-attachments/assets/6fc35338-b605-4b1a-9a94-659b7f4d1a57)

El primer laboratorio nos explica que tiene una función para comprobar el stock de un producto, el cual hace una petición al sistema interno. Para resolverlo tenemos que cambiar la URL de la comprobación del stock para acceder al panel de administración y eliminar el usuario `Carlos`.

Lo primero será configurar un servidor proxy para que registre todo el tráfico que se genere en el navegador web, para ello debemos ejecutar Burp Suite e ir a la pestaña de `Proxy` -> `Options` y verificar si tenemos el proxy como se muestra a continuación:

![186309125-51ad97c3-b823-4825-8bc4-43fb74091e88](https://github.com/user-attachments/assets/b2815890-a475-45db-91fe-2a91aa1bea50)

Luego en el navegador, por ejemplo Firefox ir a `Preferencias` -> `Avanzadas` -> `Proxy de Red` -> `Configuración` -> `Configuración Manual del Proxy`

En Proxy HTTP escribir `127.0.0.1`, en Puerto escribir `8080` y tildar el mismo proxy para todo:

![186309874-aa443078-e385-45dd-bbb0-faca9508e320](https://github.com/user-attachments/assets/6bff1037-47f8-4d6b-86a8-f41743fb2370)

Ahora lo que haremos es meternos en cualquier producto.

![2](https://github.com/user-attachments/assets/1ab0b753-0938-4fb9-b34c-6baf771465d1)

Buscamos la función de stock y pulsamos en ella.

![3](https://github.com/user-attachments/assets/9d127d7a-66f7-4c8e-ad21-c2dab40f44dd)

Desde Burp se interceptará la petición de tipo POST.

![4](https://github.com/user-attachments/assets/28b89d89-d9f4-4386-93cb-df51e854ccac)

Podemos observar que hay un parámetro que se llama stockApi con un valor en formato URL, para que sea legible podemos seleccionarlo y pinchar en URL-decode.

![5](https://github.com/user-attachments/assets/9f1811f0-8422-4c85-9b9c-de17e9352fd7)

![6](https://github.com/user-attachments/assets/b896e023-4080-4834-b953-c787a75d028b)

Luego enviamos la petición al Repeater y cambiamos la URL del parámetro stockApi a `http://localhosy/admin`. De esta forma, estamos enviando una petición al servidor web, el cual realizará una petición interna al localhost del panel de administración, es una petición que se realiza a sí misma, por lo tanto, tiene permiso.

![7](https://github.com/user-attachments/assets/2b0039de-8220-4f00-85f0-e8d18a5be85d)

En el Response (Render) podemos ver que estamos en el panel de administración y que tenemos acceso a los usuarios.

![8](https://github.com/user-attachments/assets/c44cbad3-58e1-4ab0-a846-53d0b1a59c81)

Como no es interactivo, lo que debemos de hacer es buscar en el código fuente del Response la palabra "Carlos".

![9](https://github.com/user-attachments/assets/51cdb0b8-33f1-4406-bc72-d7875cb4421a)

Podemos ver que el enlace para eliminar al usuario Carlos es `/admin/delete?username=Carlos`. Este valor debe asignarse en el parámetro stockApi y enviarse la petición para que los cambios se realicen.

![10](https://github.com/user-attachments/assets/3ea7322d-a76f-47b6-ab51-32f09ae87c5d)

Si volvemos a acceder al panel de administración, el usuario Carlos ya no aparece, y por lo tanto, el laboratorio estaría finalizado.

![11](https://github.com/user-attachments/assets/f6d0825c-cc26-4222-a327-a4d79054a091)

El siguiente laboratorio tiene también una función de stock y que realiza una petición al sistema interno. Pero para este caso debemos escanear el rango de la red interna y encontrar en que dirección IP tenemos acceso al panel de administración para luego eliminar el usuario `Carlos`. 

![12](https://github.com/user-attachments/assets/6d8a01ed-d8a1-4d5d-af0c-267c0edade65)

Si accedemos al panel admin desde la aplicación web nos dirá que no se encuentra.

![14](https://github.com/user-attachments/assets/4006e8f6-bd47-4778-adfc-46c1ead403c6)

Volveremos a ingresar a un producto y haremos clic en la funcionalidad de stock.

![13](https://github.com/user-attachments/assets/6399b233-792c-4638-8d46-855d49cabe6a)

Al capturar la petición con Burp, notamos que es similar, pero se realiza a una IP interna `192.168.0.1` en el puerto 8080. Realizar una petición desde una IP interna está mal, ya que proporciona información al atacante en bandeja.

![15](https://github.com/user-attachments/assets/ff8e3fdc-3cac-4e0b-861f-6353c4d9da60)

Enviaremos la petición al Repeater y modificaremos el parámetro de stock para ver si el panel de administración se encuentra en dicha IP `http://192.168.0.1:8080/admin`.

![16](https://github.com/user-attachments/assets/7261a766-539d-439a-a026-7319b67b988f)

Nos devuelve un error, por lo tanto, la interfaz de admin no se encuentra en esa IP. Envíamos la petición al Intruder.

![17](https://github.com/user-attachments/assets/19603410-e7a9-4e18-9877-9bd5343c8048)

Aquí seleccionamos el último dígito de la IP ".1" y le damos en "Add §".

![18](https://github.com/user-attachments/assets/d8a6e4cf-8d70-433d-af2f-216c6f6448d8)

Luego nos dirigimos a la pestaña de Payloads y en tipo lo dejamos en númerico.

![20](https://github.com/user-attachments/assets/e5020e6c-19fe-49cd-a29e-ca7d8bdc823c)

En la configuración del payload copiaremos lo siguiente: va a ir desde 1 hasta 254 (todas direcciones IP posibles de una red /24) y que vaya de uno en uno. 

![21](https://github.com/user-attachments/assets/253a03bd-7c7a-4a4d-ae53-8fee4b646d04)

Una vez configurado todo, le damos en "Start Attack".

Vemos que se comienzan a enviar las peticiones. Inicialmente, recibimos dos tipos de respuestas: una con un código 400 y otra con un código 500, que no nos son útiles. Para buscar una petición diferente, seleccionamos 'Status' y observamos que hay una que nos devuelve un código 200.

![22](https://github.com/user-attachments/assets/b453347b-7beb-40af-afad-0aa39cbef33a)

Si pulsamos en ella, podemos ver que se realiza una petición a la 192.168.0.142, y efectivamente, se puede acceder al panel de administración. Al buscar la palabra 'Carlos' en la respuesta, encontraremos el enlace para eliminar el usuario `http://192.168.0.142:8080/admin/delete=username=carlos`.

![23](https://github.com/user-attachments/assets/8d199d93-8ddf-4af8-ba82-9af345d54876)

Seguidamente volveremos al Reapter y modificamos el parámetro de stockApi con el enlace anterior, luego envíamos dicha request.

![24](https://github.com/user-attachments/assets/479d714c-3a56-4dbb-af99-8da5d7662656)

Finalmente, si comprobamos el renderizado de la respuesta, podemos ver que el usuario Carlos ha sido eliminado y que el laboratorio se completó exitosamente.

![25](https://github.com/user-attachments/assets/6f2c5b0d-8197-459f-9ab2-fad3c1679d46)

<h1 align="center"></h1>

</br>

### MITIGAR VULNERABILIDAD SSRF (Server Side Request Forgery)

Cuando se permite que los usuarios ingresen URLs en una aplicación web, existe el riesgo de un ataque SSRF (Server-Side Request Forgery). Este tipo de vulnerabilidad ocurre cuando un atacante puede manipular el servidor para realizar solicitudes a recursos internos o externos no autorizados.

#### Ejemplo de Código Vulnerable

```javascript
function validUrl(url) {  
  return url;
}

```


</br>

<h1 align="center"></h1>

<h3 align="center"><ins>ADVERTENCIA<ins></h3>

<h4 align="center">Esto es con fines de aprendizaje, no nos hacemos responsables ni el fundador, ni el creador del tema del mal uso de esta herramienta u información.</h4>



#### ~R3LI4NT~
