<p align="center">
  <a href="https://github.com/DenverCoder1/readme-typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=1000&color=D1F700&width=650&lines=Ataque+de+Inyección+SQL+Manual+y+Automático"></a>
</p>

<h1 align="center"></h1>

<h3 align="center"><ins>VULNERABILIDAD de Inyección SQL</ins></h3>

Las vulnerabilidades de inyección SQL representan brechas de seguridad que posibilitan la ejecución de comandos en lenguaje SQL para interactuar con la base de datos de un sitio web. La mayoría de las aplicaciones web se basan en bases de datos en su parte posterior para organizar los diversos elementos que la constituyen, tales como:

- **Nombres de usuarios:** Supongamos que un sitio web tiene un formulario de inicio de sesión con un campo de usuario y contraseña. La inyección SQL podría ser algo así:
  
```sql
Usuario: ' OR '1'='1
Contraseña: (dejar en blanco o cualquier cosa)
```
Esta inyección manipularía la consulta SQL para que la condición siempre sea verdadera, lo que permite al atacante acceder a la cuenta sin necesidad de una contraseña válida.

- **Contraseñas:** En el caso de la contraseña, si la base de datos no está bien protegida y se almacenan las contraseñas de forma insegura, un ataque de inyección podría intentar algo como:

```sql
Usuario: (cualquier usuario)
Contraseña: ' OR ''='
```
Si las contraseñas están almacenadas en texto plano o de alguna manera vulnerable, esta inyección podría permitir el acceso a cualquier cuenta.

- **Precios:** Supongamos que hay un campo para actualizar precios de productos. Una inyección SQL en este campo podría ser:

```sql
Nuevo Precio: 99.99; DROP TABLE Productos;
```
Esta inyección, si no está protegida, puede ejecutar múltiples comandos SQL. En este caso, además de cambiar el precio a 99.99, también eliminaría la tabla completa de productos.

- **Productos:** Para el campo de productos, si hay una consulta de búsqueda, un ejemplo de inyección SQL podría ser:

```sql
Campo de búsqueda: ' OR 1=1--
```
Esto modificaría la consulta para que devuelva todos los productos, ignorando cualquier filtro que el sitio web hubiera implementado.

Estos son solo algunos ejemplos de los valores que conforman las bases de datos, y a través de una inyección SQL, un atacante puede leer, modificar, añadir o eliminar estos elementos. Un fallo en SQL suele surgir debido a la incorrecta filtración de variables en un programa que maneja o genera sentencias SQL. Esto ocurre especialmente cuando se solicitan entradas de usuario de cualquier naturaleza sin una validación adecuada, como puede ser el caso de un nombre y contraseña. Sin embargo, en lugar de proporcionar esta información, un atacante envía una declaración SQL intrusiva que se ejecuta en la base de datos.


<p align="center">
  <img src="https://raw.githubusercontent.com/R3LI4NT/articulos/main/Pentesting/WEB/img/SQL_Injection.png">
</p>

Antes de buscar vulnerabilidades de inyección SQL, es fundamental asegurarse de tener autorización del propietario del sitio web para llevar a cabo pruebas de pentesting. Es crucial realizar estas pruebas únicamente en entornos legales. El primer paso para identificar una vulnerabilidad SQL es determinar la tecnología que utiliza la página web para saber si emplea bases de datos que utilizan SQL, como Oracle, MySQL o SQL Server. Herramientas como Wappalyzer (una extensión de navegador) o programas como WhatWeb pueden proporcionar información sobre la tecnología empleada en un sitio web.

<h1 align="center"></h1>

</br>


### PROCESO MANUAL

Una inyección SQL se puede aprovechar de dos maneras distintas. En primer lugar, de manera manual, donde el atacante introduce personalmente comandos maliciosos en los campos de entrada de la aplicación web. Esto implica que el atacante conoce la estructura de la base de datos y manipula las consultas para realizar acciones no autorizadas.

En segundo lugar, existe la inyección automatizada, que se realiza mediante herramientas especializadas como sqlmap. Estas herramientas están diseñadas para simplificar el proceso: analizan automáticamente la página web en busca de vulnerabilidades de inyección SQL, determinan si la página es susceptible y, en caso afirmativo, ejecutan ataques. La automatización significa que el usuario solo necesita especificar las opciones deseadas para optimizar el escaneo, ya que la herramienta se encarga del proceso de manera autónoma. Este enfoque facilita la identificación y explotación de vulnerabilidades sin la necesidad de intervención manual extensa.

##### Detectar página vulnerable a SQLi

Para descubrir si una página es vulnerable a la inyección SQL, es esencial examinar sus parámetros. Pongamos el siguiente escenario:

Imaginemos que encontramos una página web común que utiliza numerosos parámetros a través del método GET (donde la página envía datos a través de la URL). Entonces, visualicemos algo como esto:

Supongamos que la página tiene la siguiente estructura de URL:
```
http://www.ejemplo.com/algo.php?id=1
```

En esta URL, "id=1" son parámetros que la página utiliza para recibir información. Estos parámetros pueden ser susceptibles a inyecciones SQL si no se manejan adecuadamente. Un atacante podría intentar modificar estos parámetros al inyectar código SQL malicioso para manipular la consulta de la base de datos y potencialmente obtener o modificar datos de manera no autorizada. La detección de vulnerabilidades en estos parámetros es crucial para garantizar la seguridad de la aplicación web.

Para verificar si una página es vulnerable a la inyección SQL, una técnica simple es añadir una comilla simple (') al final de cada parámetro y observar si esto provoca un error en la base de datos. Aquí está el proceso:

Imaginemos que tenemos una URL como esta:
```
http://www.ejemplo.com/algo.php?id=1
```

Para probar la vulnerabilidad, añadiríamos una comilla simple al final del primer parámetro, así:
```
http://www.ejemplo.com/algo.php?id=1'
```

Si al hacer esto obtenemos un mensaje de error o una respuesta inusual, podría ser indicativo de una vulnerabilidad de inyección SQL. Este método simple permite a los probadores de seguridad evaluar si la aplicación web es propensa a la inyección SQL al observar cómo maneja las comillas simples en sus parámetros.

![1](https://github.com/R3LI4NT/articulos/assets/75953873/3ba175f1-b8d8-4b19-a1be-4d7447b14d9b)

Ahora que hemos identificado un parámetro vulnerable, el siguiente paso es determinar el número de columnas utilizadas por la página. Para realizar esta tarea, usamos comandos como `order by` y `group by` para probar diferentes números de columnas. Aquí hay un ejemplo práctico:

```
1' ORDER BY 1 --+	
1' ORDER BY 2 --+	
1' ORDER BY 3 --+	
1' ORDER BY 4 --+
1' ORDER BY 5 --+	
etc...

1' GROUP BY 1 --+	
1' GROUP BY 2 --+	
1' GROUP BY 3 --+	
1' GROUP BY 4 --+
1' GROUP BY 5 --+
etc...
```

Hagamos una analogía para comprender el proceso de identificar la cantidad de columnas de una página web que son vulnerables a la inyección SQL. Imagina que estás tratando de abrir una serie de cajas y necesitas descubrir cuántas hay dentro. Tienes una llave que puede abrir cualquier caja, pero cada vez que intentas abrir una, la caja te dice cuántas cajas hay en total.

En términos de páginas web que son vulnerables a la inyección SQL, es como si estuviéramos probando diferentes “corchetes” (números) para ver cuántas “cajas” (columnas) hay en la página.

```
http://www.ejemplo.com/algo.php?id=1' order by 1 --+ 
http://www.ejemplo.com/algo.php?id=1' order by 2 --+ 
http://www.ejemplo.com/algo.php?id=1' order by 3 --+ 
http://www.ejemplo.com/algo.php?id=1' order by 4 --+
http://www.ejemplo.com/algo.php?id=1' order by 10 --+
http://www.ejemplo.com/algo.php?id=1' order by 19 --+ 
http://www.ejemplo.com/algo.php?id=1' order by 20 --+ # Error
```

En este caso, cuando intentamos abrir la "caja" número 20, la página nos muestra un mensaje de error indicando que la columna es desconocida. Esto nos dice que la página está utilizando 19 columnas, ya que el intento de acceder a la columna 20 generó un error.
